# Especificaciones del Megaprocessor para Ensamblador en C

## 1. ARQUITECTURA DEL MEGAPROCESSOR

### 1.1 Características Generales
- **Procesador**: 16-bit
- **Espacio de direcciones**: 64K (16 bits)
- **Bus de datos externo**: 8-bit (ancho interno: 16-bit)
- **Pipeline**: 1 etapa
- **Formato de instrucciones**: 8-bit opcode + hasta 2 bytes de dato inmediato

### 1.2 Registros
| Registro | Tamaño | Propósito |
|----------|--------|----------|
| R0, R1, R2, R3 | 16-bit | Registros de propósito general |
| PC | 16-bit | Program Counter |
| SP | 16-bit | Stack Pointer |
| PS | 16-bit | Processor Status Register |
| H | 16-bit | Registro auxiliar (helper/scratchpad) |

### 1.3 Registro de Estado (PS)
El registro PS se actualiza con cada instrucción. Sus bits son:
- **Z**: Zero flag
- **N**: Negative flag
- **C**: Carry flag
- **V**: Overflow flag
- **U**: Unsigned/user flag
- **X**: Extended carry (usado en operaciones ADDX/SUBX)
- **D**: Bit de control para división (define comportamiento del resto negativo)

---

## 2. CONJUNTO DE INSTRUCCIONES COMPLETO

### Estructura Opcode
256 instrucciones posibles (0x00-0xFF), organizadas en 16 grupos de 16 instrucciones.

```
┌─────────────────────────────────────────────────────────────────┐
│ GRUPOS DE INSTRUCCIONES (Opcode = 0xGG donde G=grupo, I=índice) │
└─────────────────────────────────────────────────────────────────┘

Grupo 0x00-0x07: Operaciones básicas (MOV, ALU)
Grupo 0x08-0x0F: Continuación de operaciones básicas
Grupo 0x80-0x8F: Acceso indirecto a memoria
Grupo 0x90-0x9F: Post-incremento de memoria
Grupo 0xA0-0xAF: Stack relative
Grupo 0xB0-0xBF: Acceso a memoria absoluta
Grupo 0xC0-0xCF: Push/Pop y stack
Grupo 0xD0-0xDF: Immediatos
Grupo 0xE0-0xEF: Saltos condicionales
Grupo 0xF0-0xFF: Miscelánea
```

### 2.1 GRUPO 0x00: Operaciones MOV/ALU Básicas

#### Formato Base (Opcodes 0x00-0x0F)
```
0x00 (MOV grupo)  → sxt r0, test r0, xor r0,r0, inv r0, add r0,r0, addq r0,#2, neg r0, abs r0
0x01 (MOV grupo)  → move r1,r0, and r1,r0, xor r1,r0, or r1,r0, add r1,r0, addq r1,#2, sub r1,r0, cmp r1,r0
0x02 (MOV grupo)  → move r2,r0, and r2,r0, xor r2,r0, or r2,r0, add r2,r0, addq r2,#2, sub r2,r0, cmp r2,r0
0x03 (MOV grupo)  → move r3,r0, and r3,r0, xor r3,r0, or r3,r0, add r3,r0, addq r3,#2, sub r3,r0, cmp r3,r0
0x04-0x0F         → Continuación con diferentes registros destino
```

#### Instrucciones (Codificación)
| Nombre | Opcode | Descripción |
|--------|--------|-------------|
| SXT RA | 0x0{A*0x10} | Sign extend LSB de RA |
| TEST RA | 0x1{A*0x10} | Set Z, N según RA |
| XOR RA, RB | 0x2{(A*4+B)*0x10} | XOR lógico |
| INV RA | 0x3{A*0x10} | Invertir todos los bits |
| ADD RA, RB | 0x4{(A*4+B)*0x10} | Suma |
| ADDQ RA, #small | 0x5/0x6/0x8/0x9 | Suma rápida (valores: ±1, ±2) |
| NEG RA | 0x7{A*0x10} | Negación |
| ABS RA | 0x7{(A+8)*0x10} | Valor absoluto |
| MOVE RA, RB | 0x0{(A*4+B)*0x10} | Mover RB → RA |
| AND RA, RB | 0x2{(A*4+B)*0x10} | AND lógico (RB ≠ RA) |
| OR RA, RB | 0x3{(A*4+B)*0x10} | OR lógico |
| SUB RA, RB | 0x7{(A*4+B)*0x10} | Resta (RB ≠ RA) |
| CMP RA, RB | 0x8{(A*4+B)*0x10} | Comparar (actualiza PS) |

### 2.2 GRUPO 0x80: Acceso Indirecto a Memoria

```
Opcode: 0x8{m} donde m determina registro e instrucción

ld.w r0, (r2)  / ld.w r1, (r2)
ld.w r0, (r3)  / ld.w r1, (r3)
ld.b r0, (r2)  / ld.b r1, (r2)
ld.b r0, (r3)  / ld.b r1, (r3)
st.w (r2), r0  / st.w (r2), r1
st.w (r3), r0  / st.w (r3), r1
st.b (r2), r0  / st.b (r2), r1
st.b (r3), r0  / st.b (r3), r1
```

### 2.3 GRUPO 0x90: Post-Incremento (RI++)

```
ld.w r0, (r2++)  / ld.w r1, (r2++)
ld.w r0, (r3++)  / ld.w r1, (r3++)
ld.b r0, (r2++)  / ld.b r1, (r2++)
ld.b r0, (r3++)  / ld.b r1, (r3++)
st.w (r2++), r0  / st.w (r2++), r1
st.w (r3++), r0  / st.w (r3++), r1
st.b (r2++), r0  / st.b (r2++), r1
st.b (r3++), r0  / st.b (r3++), r1
```

### 2.4 GRUPO 0xA0: Stack Relative (SP + m)

```
m es offset 8-bit unsigned

ld.w r0, (sp+m)  / ld.w r1, (sp+m)
ld.w r2, (sp+m)  / ld.w r3, (sp+m)
ld.b r0, (sp+m)  / ld.b r1, (sp+m)
ld.b r2, (sp+m)  / ld.b r3, (sp+m)
st.w (sp+m), r0  / st.w (sp+m), r1
st.w (sp+m), r2  / st.w (sp+m), r3
st.b (sp+m), r0  / st.b (sp+m), r1
st.b (sp+m), r2  / st.b (sp+m), r3
```

### 2.5 GRUPO 0xB0: Acceso Absoluto (addr)

```
Se requieren 2 bytes de dirección inmediato (little-endian)

ld.w r0, addr  / ld.w r1, addr
ld.w r2, addr  / ld.w r3, addr
ld.b r0, addr  / ld.b r1, addr
ld.b r2, addr  / ld.b r3, addr
st.w addr, r0  / st.w addr, r1
st.w addr, r2  / st.w addr, r3
st.b addr, r0  / st.b addr, r1
st.b addr, r2  / st.b addr, r3
```

### 2.6 GRUPO 0xC0: Push/Pop y Stack

```
0xC0: pop r0, pop r1, pop r2, pop r3, pop ps, NOP, ret, reti
0xC1: push r0, push r1, push r2, push r3, push ps, trap #n, jsr (r0), jsr addr
0xC2-0xCF: Variaciones adicionales
```

| Instrucción | Opcode | Descripción |
|-------------|--------|-------------|
| PUSH RA | 0xC8-0xCB | Push a stack |
| PUSH PS | 0xCC | Push status |
| POP RA | 0xC0-0xC3 | Pop de stack |
| POP PS | 0xC4 | Pop status |
| RET | 0xC6 | Return from subroutine |
| RETI | 0xC7 | Return from interrupt |
| JSR addr | 0xCD | Jump to Subroutine (2 bytes addr) |
| JSR (R0) | 0xCE | Jump via R0 |
| TRAP #n | 0xCD | Software trap |

### 2.7 GRUPO 0xD0: Immediatos (LD Inmediato)

```
Datos inmediatos de 8 o 16 bits

ld.w r0, #data  / ld.w r1, #data
ld.w r2, #data  / ld.w r3, #data
ld.b r0, #data  / ld.b r1, #data
ld.b r2, #data  / ld.b r3, #data

shift r0, descr / shift r1, descr
shift r2, descr / shift r3, descr

bit r0, descr   / bit r1, descr
bit r2, descr   / bit r3, descr
```

### 2.8 GRUPO 0xE0: Saltos Condicionales (Bcc)

```
Formato: Bcc dd (donde dd es desplazamiento signed 8-bit, -128...+127)

BCC (C clear)   - Branch if Carry Clear
BCS (C set)     - Branch if Carry Set
BNE (Z clear)   - Branch if Not Equal
BEQ (Z set)     - Branch if Equal
BVC (V clear)   - Branch if oVerflow Clear
BVS (V set)     - Branch if oVerflow Set
BPL (N clear)   - Branch if Plus
BMI (N set)     - Branch if Minus
BGE             - Branch if Greater or Equal (signed)
BLT             - Branch if Less Than (signed)
BGT             - Branch if Greater Than (signed)
BLE             - Branch if Less or Equal (signed)
BUC (U clear)   - Branch if U clear
BUS (U set)     - Branch if U set
BHI             - Branch if Higher (unsigned)
BLS             - Branch if Lower or Same (unsigned)
```

| Condición | Opcode | Mnemónico |
|-----------|--------|-----------|
| Carry Clear | 0xE0 | BCC |
| Carry Set | 0xE1 | BCS |
| Not Equal (Z=0) | 0xE2 | BNE |
| Equal (Z=1) | 0xE3 | BEQ |
| Overflow Clear | 0xE4 | BVC |
| Overflow Set | 0xE5 | BVS |
| Plus (N=0) | 0xE6 | BPL |
| Minus (N=1) | 0xE7 | BMI |
| Greater/Equal (signed) | 0xE8 | BGE |
| Less Than (signed) | 0xE9 | BLT |
| Greater Than (signed) | 0xEA | BGT |
| Less/Equal (signed) | 0xEB | BLE |
| U clear | 0xEC | BUC |
| U set | 0xED | BUS |
| Higher (unsigned) | 0xEE | BHI |
| Lower/Same (unsigned) | 0xEF | BLS |

### 2.9 GRUPO 0xF0: Instrucciones Miscelánea

| Instrucción | Opcode | Descripción | Bytes |
|-------------|--------|-------------|-------|
| MOVE R0, SP | 0xF0 | SP → R0 | 1 |
| MOVE SP, R0 | 0xF1 | R0 → SP | 1 |
| JMP (R0) | 0xF2 | Jump via R0 | 1 |
| JMP addr | 0xF3 | Jump a address | 3 (1+2) |
| ANDI PS, #data | 0xF4 | AND inmediato PS | 2 |
| ORI PS, #data | 0xF5 | OR inmediato PS | 2 |
| ADDI SP, #data | 0xF6 | ADD SP + signed 8-bit | 2 |
| SQRT | 0xF7 | Raíz cuadrada R1 → R0 | 1 |
| MULU | 0xF8 | Multiply unsigned (R0*R1) | 1 |
| MULS | 0xF9 | Multiply signed (R0*R1) | 1 |
| DIVU | 0xFA | Divide unsigned (R0/R1) | 1 |
| DIVS | 0xFB | Divide signed (R0/R1) | 1 |
| ADDX R0, R1 | 0xFC | Add with extended carry | 1 |
| SUBX R0, R1 | 0xFD | Substract with extended carry | 1 |
| NEGX R0 | 0xFE | Negate with extended carry | 1 |
| NOP | 0xFF | No Operation | 1 |

### 2.10 Operaciones de Bits (BIT Instructions)

```
BSET RA, descriptor    - Set bit
BCLR RA, descriptor    - Clear bit
BCHG RA, descriptor    - Change/invert bit

Descriptor puede ser:
- 4-bit immediato (0-15)
- Registro R0-R3 (se usan solo los 4 LSB)

Ejemplo: BSET R0, #3     → Set bit 3 en R0
         BCLR R1, R2     → Clear bit en R1 (posición en R2)
```

### 2.11 Operaciones de Desplazamiento

```
ASL RA, descriptor     - Arithmetic Shift Left
ASR RA, descriptor     - Arithmetic Shift Right
LSL RA, descriptor     - Logical Shift Left
LSR RA, descriptor     - Logical Shift Right
ROL RA, descriptor     - Rotate Left
ROR RA, descriptor     - Rotate Right
ROXL RA, descriptor    - Rotate Left with Carry
ROXR RA, descriptor    - Rotate Right with Carry

Descriptor: -16...+15 (5-bit signed immediato o registro)

Modificador opcional:
[.wt]  - Calculate weight (count of ones in result)
```

---

## 3. CICLOS DE EJECUCIÓN

```
Ciclos = 1 + (bytes de acceso a memoria)

Ejemplos:
- MOV R0, R1        → 1 byte → 1 ciclo
- ADD R0, R1        → 1 byte → 1 ciclo
- LD.W R0, 0x1234   → 5 bytes (1 inst + 2 addr + 2 word) → 5 ciclos
- LD.B R0, 0x1234   → 4 bytes (1 inst + 2 addr + 1 byte) → 4 ciclos
- PUSH R0           → 1 byte → 1 ciclo
- JSR 0x5000        → 3 bytes (1 inst + 2 addr) → 3 ciclos
```

---

## 4. ALMACENAMIENTO EN MEMORIA

- **Bytes**: Acceso directo (8-bit)
- **Words**: Little-endian (16-bit)
- **Extensión de bytes**: Zero-extended al cargar en registro de 16-bit
- **Sign Extension**: Usar SXT si se necesita signo

Ejemplo: LD.B R0, addr → carga 8-bit y expande con ceros a 16-bit

---

## 5. FORMATO DE ALIAS ÚTILES

```
Aliases (instrucciones derivadas):
CLR RA      → XOR RA, RA                (limpiar registro)
INC RA      → ADDQ RA, #1               (incrementar)
DEC RA      → ADDQ RA, #-1              (decrementar)
```

---

## 6. MANEJO DE EXCEPCIONES

```
4 excepciones con vectores en:
- Base 0x0000 o 0xFFF0 (selectable por hardware)
- Offsets: 0x0, 0x4, 0x8, 0xC

Vector 0 (offset 0x0):   Reset
Vector 1 (offset 0x4):   Undefined instruction
Vector 2 (offset 0x8):   Divide by zero
Vector 3 (offset 0xC):   TRAP instruction
```

---

## 7. ESTRUCTURA PARA ENSAMBLADOR EN C

### 7.1 Estructura de Entrada (Línea de Ensamblaje)
```c
typedef struct {
    char* label;          // Etiqueta opcional
    char* mnemonic;       // Mnemónico (ADD, MOV, etc.)
    char* operand1;       // Operando 1
    char* operand2;       // Operando 2
    char* operand3;       // Operando 3 (si existe)
    int line_number;      // Número de línea
} instruction_t;
```

### 7.2 Estructura de Símbolo (Symbol Table)
```c
typedef struct {
    char* name;
    uint16_t address;
    int type;             // LABEL, DEFINE, etc.
} symbol_t;
```

### 7.3 Estructura de Token
```c
typedef struct {
    char* value;
    int type;             // MNEMONIC, REGISTER, IMMEDIATE, etc.
    int line;
} token_t;
```

### 7.4 Tipos de Operandos
```c
#define OP_REGISTER      1
#define OP_IMMEDIATE     2
#define OP_ADDRESS       3
#define OP_INDIRECT      4
#define OP_POSTINC       5
#define OP_STACK_REL     6
#define OP_LABEL         7
```

---

## 8. PROCESO DE ENSAMBLAJE (DOS PASADAS)

### Pasada 1: Análisis y construcción de tabla de símbolos
1. Parsear cada línea
2. Identificar etiquetas
3. Calcular direcciones
4. Guardar símbolos

### Pasada 2: Generación de código
1. Convertir mnemonicos a opcodes
2. Resolver referencias de etiquetas
3. Generar código de máquina
4. Validar restricciones de registros

---

## 9. RESTRICCIONES Y REGLAS

### Reglas de Registros
- **MOVE RA, RB**: RB no puede ser igual a RA
- **CMP RA, RB**: RB no puede ser igual a RA
- **AND RA, RB**: RB no puede ser igual a RA
- **SUB RA, RB**: RB no puede ser igual a RA
- **ADD RA, RB**: RB PUEDE ser igual a RA

### Direccionamiento
- **Indirecto**: Solo R2 o R3 permitidos
- **Post-incremento**: (R2++) o (R3++)
- **Stack relative**: (SP + m) donde m es 8-bit unsigned
- **Absoluto**: Dirección 16-bit

### Tamaño de Instrucciones
```
1 byte:  Instrucciones sin operandos o solo registros
2 bytes: Instrucción + 1 byte inmediato
3 bytes: Instrucción + 2 bytes (dirección o inmediato 16-bit)
```

---

## 10. FORMATO DE SALIDA ESPERADA

### Listado (LIS)
```
Addr  Code           Label      Mnemonic    Operandos
0000  4001           START:     MOV         R1,R0
0001  3501           LOOP:      XOR         R1,R1
0002  5100           ADD        R1,R0
0003  E0FE           BNE        LOOP
0004  F3 0000        JMP        START
```

### Código de Máquina (HEX)
```
:020000040000F9
:10000000400135015100E0FEF30000...
:00000001FF
```

---

## 11. REFERENCIAS DE OPCODES COMPLETA

Ver tabla en sección 2 para detalles completos de cada grupo de instrucciones.

**Nota**: Opcode 0xC5 no se usa (mapeado a NOP)

---

## 12. HERRAMIENTAS Y LINKER

El ensamblador debe producir:
1. **Tabla de símbolos** para el linker
2. **Código objeto** con referencias relocalizables
3. **Información de depuración** (direcciones, líneas)
4. **Reporte de errores** detallado

---

**Documento generado desde las especificaciones técnicas del Megaprocessor**
**Sitio: https://www.megaprocessor.com/**
**Arquitecto: James Newman**
