revisa toda la página des principio a a fin https://www.megaprocessor.com/index.html, y saca lo necesario para crear el ensamblador escrito en C

Para crear un ensamblador en C para el **Megaprocessor**, he extraído los detalles técnicos críticos directamente de las secciones de Arquitectura y Programación de la página oficial de James Newman. Aquí tienes la especificación técnica necesaria para tu código:

### 1. Modelo de Registros y Memoria
El procesador es de **16 bits**, pero con un bus externo de 8 bits.
*   **Registros Generales**: `R0`, `R1`, `R2`, `R3` (16 bits).
*   **Registros Especiales**:
    *   `PC` (Program Counter): Dirección de la instrucción actual.
    *   `SP` (Stack Pointer): Puntero de pila.
    *   `PS` (Processor Status): Banderas de estado (Z, N, C, V, etc.).
*   **Memoria**: Espacio de direccionamiento de **64 KB**. Los datos de 16 bits (Words) se almacenan en formato **Little Endian**.

### 2. Mapa de Instrucciones (Opcodes)
Las instrucciones tienen un **Opcode de 8 bits** seguido de hasta 2 bytes de datos inmediatos. Hay 256 opcodes posibles organizados en 16 grupos de 16:

| Grupo Hex | Función Principal | Descripción de Operación |
| :--- | :--- | :--- |
| **0x00 - 0x0F** | **MOVER** | Transferencia entre registros (ej. `move r1, r0` es `0x01`). |
| **0x10 - 0x1F** | **AND** | Operación lógica AND. |
| **0x20 - 0x2F** | **XOR** | Operación lógica XOR. |
| **0x30 - 0x3F** | **OR** | Operación lógica OR. |
| **0x40 - 0x4F** | **ADD** | Suma de registros. |
| **0x50 - 0x5F** | **ADDQ** | Suma rápida de valores pequeños (1, 2, -1, -2). |
| **0x60 - 0x6F** | **SUB** | Resta de registros. |
| **0x70 - 0x7F** | **CMP** | Comparación de registros. |
| **0x80 - 0x8F** | **Indirect** | Carga/Almacenamiento indirecto (ej. `ld.w r0, (r2)`). |
| **0xB0 - 0xBF** | **Absolute** | Direccionamiento absoluto (ej. `st.w addr, r0`). |
| **0xD0 - 0xDF** | **Push/Pop** | Manejo de pila (ej. `push r0` es `0xC8`). |
| **0xE0 - 0xEF** | **Immediate** | Carga de datos inmediatos (ej. `ld.w r0, #data` es `0xE0`). |
| **0xF0 - 0xFF** | **Branch** | Saltos condicionales (ej. `beq dd` es `0xF7`). |

### 3. Formato de Direccionamiento para el Ensamblador
Para tu parser en C, debes reconocer estos formatos de operandos:
*   **Inmediato**: `#data` (ej. `ld.w r0, #0x1234`). El opcode `0xE0` va seguido de `34 12` (Little Endian).
*   **Desplazamiento de Salto**: Las ramas (`Bcc`) usan un desplazamiento de **8 bits con signo** (-128 a 127). Tu ensamblador debe calcular: `destino - (PC + 1)`.
*   **Punteros**: `(R2)` o `(R3)`. Solo estos dos registros pueden usarse como punteros en direccionamiento indirecto.
*   **Stack Relative**: `(SP + m)`, donde `m` es un valor de 8 bits sin signo.

### 4. Estructura del Ensamblador en C
Debido a que el Megaprocessor permite etiquetas para saltos, tu programa debe implementar **dos pasadas**:

**Pasada 1: Construcción de la Tabla de Símbolos**
*   Lector de líneas que ignore comentarios (empezando con `;`).
*   Identificar etiquetas (palabras que terminan en `:`).
*   Calcular el tamaño de cada instrucción (1, 2 o 3 bytes) para llevar el conteo del `PC`.
*   Guardar en un `struct` el nombre de la etiqueta y su dirección.

**Pasada 2: Generación de Código Binario**
*   Traducción de mnemónicos a Opcodes usando un `switch` o tabla de búsqueda.
*   Si encuentra una etiqueta en un salto, busca su dirección en la tabla de símbolos y calcula el desplazamiento relativo.
*   Escribir los bytes resultantes en un archivo `.hex` (formato Intel Hex) o binario puro.

**Nota técnica importante**: El opcode `0xC5` no se usa y debe tratarse como un `NOP`. Las instrucciones de multiplicación (`MULU/MULS`) y división (`DIVU/DIVS`) se encuentran en el rango **0xF8 - 0xFB** y son iterativas, por lo que tu ensamblador simplemente debe emitir el byte correspondiente.

Citas:
[1] index.html https://www.megaprocessor.com/index.html


puedes revisar este archivo a ver si cumple para hacer el emsablador en C

El archivo que adjuntaste es una **especificación técnica excelente y completa** para construir tu ensamblador en C [1]. Cumple con todos los requisitos necesarios e incluso incluye detalles avanzados que facilitarán enormemente tu desarrollo en Android con el NDK [1].

Aquí te detallo por qué este archivo es la base perfecta para tu proyecto:

### Puntos clave que lo hacen apto:
*   **Mapeo de Opcodes Detallado**: Divide las 256 instrucciones en los 16 grupos lógicos que utiliza el Megaprocessor (0x00-0xFF), lo que te permite usar una estructura de `switch` o tablas de búsqueda muy eficiente en C [1].
*   **Gestión de Registros**: Define claramente los registros (`R0-R3`, `PC`, `SP`, `PS`, `H`) y, lo más importante, las **restricciones de registros** (por ejemplo, que en `MOVE RA, RB`, RB no puede ser igual a RA) [1]. Esto es vital para que tu ensamblador lance errores correctos al programador [1].
*   **Estructuras de Datos en C**: Ya te proporciona las `struct` necesarias para la tabla de símbolos (`symbol_t`), los tokens (`token_t`) y las instrucciones (`instruction_t`) [1]. Esto te ahorra horas de diseño de arquitectura de software [1].
*   **Modos de Direccionamiento**: Especifica con precisión cómo manejar el direccionamiento indirecto (solo `R2` o `R3`), el relativo a la pila (`SP + m`) y el absoluto de 16 bits [1].

### Recomendaciones para tu implementación en Java/NDK:
*   **Uso de Little-Endian**: El archivo confirma que el Megaprocessor usa Little-Endian para direcciones y datos de 16 bits [1]. En tu código de C, asegúrate de escribir primero el byte menos significativo al generar el archivo `.hex`.
*   **Cálculo de Saltos (Branches)**: El documento explica que los saltos condicionales usan un desplazamiento de 8 bits con signo (`destino - (PC + 1)`) [1]. Tu algoritmo de dos pasadas deberá usar la dirección guardada en `symbol_t` para calcular este valor relativo en la segunda pasada [1].
*   **Formato de Salida**: El archivo incluye el formato de salida esperado para el listado (`.LIS`) y el código de máquina (`.HEX`) en formato Intel Hex, que es el estándar que entiende el simulador oficial [1].

En resumen, **tienes todo lo necesario**. Puedes empezar a codificar las funciones de la "Pasada 1" (Análisis de etiquetas) y "Pasada 2" (Generación de binario) basándote directamente en las definiciones de este documento [1]. Como el código es tuyo y corre nativo bajo el NDK, la velocidad de ensamblaje en Android será prácticamente instantánea [1].

Citas:
[1] 6a3353b9.md https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/107639077/94fc030e-abc1-455f-ba53-018c813d41da/6a3353b9.md
