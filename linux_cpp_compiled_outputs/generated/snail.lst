   1:                    // Start with shared definitions...
   2: 0000               include "Megaprocessor_defs.asm";
   3:                    // ===============================================================
   4:                    // 
   5:                    // Megaprocessor
   6:                    // =============
   7:                    // This file holds definitions useful for writing assembler
   8:                    // programs for the Megaprocessor.
   9:                    //
  10:                    // This version : 15th May 2016
  11:                    //
  12:                    // ================================================================
  13:                    //
  14:                    // Coding
  15:                    // =======
  16:                    // definition for interrupt enable bit
  17: 0001               PS_INT_ENABLE_BIT               equ     0x01;
  18:                    
  19:                    // ================================================================
  20:                    //
  21:                    // To handle the 256 bytes of RAM built from discrete components:
  22: A000               INT_RAM_START                   equ     0xA000;
  23: 0100               INT_RAM_LEN                     equ     0x0100;
  24:                    
  25: 0004               INT_RAM_BYTES_ACROSS            equ     4;
  26: 0006               INT_RAM_BYTES_HEIGHT_AS_SHIFT   equ     6;
  27: 0040               INT_RAM_BYTES_HEIGHT            equ     64;// 1 << INT_RAM_BYTES_HEIGHT_AS_SHIFT
  28:                    
  29:                    // ================================================================
  30:                    //
  31:                    // To handle the peripherals:
  32: 8000               PERIPHERALS_BASE                equ     0x8000;
  33: 8000               TIMER_BASE                      equ     PERIPHERALS_BASE + 0x00;
  34: 8010               UART_BASE                       equ     PERIPHERALS_BASE + 0x10;
  35: 8020               INTERRUPT_BASE                  equ     PERIPHERALS_BASE + 0x20;
  36: 8030               GEN_IO_BASE                     equ     PERIPHERALS_BASE + 0x30;
  37:                    
  38:                    // register locations for the GPIO...
  39: 8030               GEN_IO_OUTPUT                   equ     GEN_IO_BASE + 0;
  40: 8032               GEN_IO_INPUT                    equ     GEN_IO_BASE + 2;
  41: 8034               GEN_IO_CTR                      equ     GEN_IO_BASE + 4;
  42:                    
  43:                    // register locations for the Timer...
  44: 8000               TIME_BLK_COUNTER                equ     TIMER_BASE + 0x00;
  45: 8002               TIME_BLK_TIMER                  equ     TIMER_BASE + 0x02;
  46: 8004               TIME_BLK_TIMER_CTRL             equ     TIMER_BASE + 0x04;
  47:                    // bit definitions for timer control register
  48: 0001               TIME_BLK_TIMER_CTRL_EN_TIMER    equ     0x01;
  49: 0002               TIME_BLK_TIMER_CTRL_CLR_COUNT   equ     0x02;
  50: 0004               TIME_BLK_TIMER_CTRL_CLR_TIMER   equ     0x04;
  51:                    
  52:                    // masks for selecting switch value on Venom Arcade Stick
  53:                    // (Switches are HIGH by "default", and go LOW on being pressed).
  54: 0001               IO_SWITCH_FLAG_UP               EQU     0x0001;
  55: 0002               IO_SWITCH_FLAG_DOWN             EQU     0x0002;
  56: 0004               IO_SWITCH_FLAG_LEFT             EQU     0x0004;
  57: 0008               IO_SWITCH_FLAG_RIGHT            EQU     0x0008;
  58: 0010               IO_SWITCH_FLAG_SQUARE           EQU     0x0010;
  59: 0020               IO_SWITCH_FLAG_TRIANGLE         EQU     0x0020;
  60: 0040               IO_SWITCH_FLAG_CIRCLE           EQU     0x0040;
  61: 0080               IO_SWITCH_FLAG_CROSS            EQU     0x0080;
  62: 0100               IO_SWITCH_FLAG_L1               EQU     0x0100;
  63: 0200               IO_SWITCH_FLAG_L2               EQU     0x0200;
  64: 0400               IO_SWITCH_FLAG_R1               EQU     0x0400;
  65: 0800               IO_SWITCH_FLAG_R2               EQU     0x0800;
  66:                    
  67:                    // register locations for the Interrupt controller...
  68: 8020               INTERRUPT_SOURCE                EQU     INTERRUPT_BASE + 0x00;
  69: 8021               INTERRUPT_MASK                  EQU     INTERRUPT_BASE + 0x01;
  70:                    
  71:                    // interrupt souurce enable/value bit masks
  72: 0001               INTERRUPT_BIT_USER              EQU     0x01;
  73: 0002               INTERRUPT_BIT_UART_SPACE        EQU     0x02;
  74: 0004               INTERRUPT_BIT_UART_RX_DATA      EQU     0x04;
  75: 0008               INTERRUPT_BIT_TIMER             EQU     0x08;
  76: 0010               INTERRUPT_BIT_COUNTER           EQU     0x10;
  77: 0020               INTERRUPT_BIT_INPUT_CHANGE      EQU     0x20;
  78:                    
  79:                    
  80:                    
  81:                    // *****************************************
  82:                    // variables...
  83: 4000               org 0x4000;
  84: 4000 00              head_x:     db;
  85: 4001 00              head_y:     db;
  86: 4002 00              tail_x:     db;
  87: 4003 00              tail_y:     db;
  88:                    
  89:                    // *****************************************
  90:                    // Code...
  91: 0000               org  0;
  92:                    
  93:                    // *****************************************
  94:                    // vectors
  95: 0000 F3 10 00        reset:       jmp    start;
  96: 0003 FF              nop;
  97: 0004 C7              ext_int:     reti;
  98: 0005 FF              nop;
  99: 0006 FF              nop;
 100: 0007 FF              nop;
 101: 0008 C7              div_zero:    reti;
 102: 0009 FF              nop;
 103: 000A FF              nop;
 104: 000B FF              nop;
 105: 000C C7              illegal:     reti;
 106: 000D FF              nop;
 107: 000E FF              nop;
 108: 000F FF              nop;
 109:                    
 110:                    // *****************************************
 111:                    start:
 112:                    // give ourselves a stack
 113: 0010 D0 00 20        ld.w    r0,#0x2000;
 114: 0013 F1              move    sp,r0;
 115:                    
 116: 0014 CF 3E 00        jsr init;
 117:                    
 118:                    busy_loop:
 119:                    // head
 120: 0017 B4 00 40        ld.b    r0,head_x;
 121: 001A B5 01 40        ld.b    r1,head_y;
 122: 001D CF 67 00        jsr advance_ptr;
 123: 0020 BC 00 40        st.b    head_x,r0;
 124: 0023 BD 01 40        st.b    head_y,r1;
 125: 0026 CF 7D 00        jsr draw_point;
 126:                    
 127:                    // tail
 128: 0029 B4 02 40        ld.b    r0,tail_x;
 129: 002C B5 03 40        ld.b    r1,tail_y;
 130: 002F CF 67 00        jsr advance_ptr;
 131: 0032 BC 02 40        st.b    tail_x,r0;
 132: 0035 BD 03 40        st.b    tail_y,r1;
 133: 0038 CF 7D 00        jsr draw_point;
 134:                    
 135: 003B F3 17 00        jmp busy_loop;
 136:                    
 137:                    // ***********************************************
 138:                    // Initialisation. Start by clearing down the internal RAM, and set
 139:                    // up first location of snail with head and tail ptrs.
 140:                    init:
 141:                    // clear our RAM
 142: 003E 20              xor     r0,r0;
 143: 003F D2 00 A0        ld.w    r2,#INT_RAM_START;
 144: 0042 D1 00 01        ld.w    r1,#INT_RAM_LEN;
 145:                    clr_loop:
 146: 0045 98              st.w    (r2++),r0;
 147: 0046 59              addq    r1,#-2;
 148: 0047 E6 FC           bne     clr_loop;
 149:                    
 150: 0049 D4 01           ld.b    r0,#1;
 151: 004B D5 17           ld.b    r1,#23;
 152: 004D D7 04           ld.b    r3,#4;
 153: 004F D2 04 A0        ld.w    r2,#INT_RAM_START + 4;
 154:                    i1:
 155: 0052 8C              st.b    (r2),r0;
 156: 0053 4E              add r2,r3;
 157: 0054 5D              addq    r1,#-1;
 158: 0055 E6 FB           bne i1;
 159:                    
 160:                    // set up head and tail ptrs...
 161: 0057 20              xor r0,r0;
 162: 0058 BC 02 40        st.b    tail_x,r0;
 163: 005B BC 03 40        st.b    tail_y,r0;
 164: 005E BC 00 40        st.b    head_x,r0;
 165: 0061 D4 17           ld.b    r0,#23;
 166: 0063 BC 01 40        st.b    head_y,r0;
 167:                    
 168: 0066 C6              ret;
 169:                    
 170:                    // ********************************************************
 171:                    // advance ptr....x in r0, y in r1
 172:                    advance_ptr:
 173: 0067 D6 01           ld.b    r2,#1;
 174: 0069 12              and r2,r0;
 175: 006A E6 07           bne ap1;
 176:                    
 177:                    // we're on an even column, head down unless at 63 when we move over
 178: 006C D6 3F           ld.b    r2,#63;
 179: 006E 76              cmp r2,r1;
 180: 006F E7 07           beq ap2;
 181: 0071 55              addq    r1,#1;
 182: 0072 C6              ret;
 183:                    
 184:                    // we're on an odd column, head up unless we're at 0 when we move over
 185:                    ap1:
 186: 0073 15              test    r1;
 187: 0074 E7 02           beq ap2;
 188: 0076 5D              addq    r1,#-1;
 189: 0077 C6              ret;
 190:                    ap2:
 191: 0078 54              addq    r0,#1;
 192: 0079 D6 1F           ld.b    r2,#0x1F;
 193: 007B 18              and r0,r2;
 194: 007C C6              ret;
 195:                    
 196:                    // ********************************************************
 197:                    // draw point...x in r0, y in r1
 198:                    draw_point:
 199:                    // first we construct the byte ptr
 200: 007D 02              move    r2,r0;
 201: 007E D3 00 A0        ld.w    r3,#INT_RAM_START;
 202: 0081 DA 1D           lsr r2,#3; // bit address to byte
 203: 0083 4B              add r3,r2;
 204: 0084 D9 02           lsl r1,#2; // y os byte offset
 205: 0086 47              add r3,r1;
 206:                    // and now the mask
 207: 0087 D5 01           ld.b    r1,#1;
 208: 0089 D6 07           ld.b    r2,#7;
 209: 008B 18              and r0,r2;
 210: 008C D9 20           lsl r1,r0;
 211:                    
 212:                    // and now apply
 213: 008E 86              ld.b    r0,(r3);
 214: 008F 24              xor r0,r1;
 215: 0090 8E              st.b    (r3),r0;
 216:                    
 217: 0091 C6              ret;
 218:                    
 219:                    // ********************************************************
 220:                    
 221:                    
